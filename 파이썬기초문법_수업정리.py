# -*- coding: utf-8 -*-
"""수업 정리.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1fazlLQtc3tmvnAkdWCfa8yqJIjjXXM6p

## 방학특강_Python-Day06

### 정보들
- Deepseek: 가성비와 적절한 성능을 갖춘 생성형 인공지능 모델
- 교재: 점프 투 파이썬
- 공지 사이트: cafe.naver.com/sazusave
- pytorch, python 공식 다큐먼트 사이트 참고할 것
- git: 분산개발환경; 관련해 알고 있는 것이 좋다

### Extra : 화면에서 한글 표시 깨지는 것 해결방법
"""

# 1. Colab 에서 한글사용 사례:
# ---------------------------
# 1) 설치
!sudo apt-get install -y fonts-nanum
!sudo fc-cache -fv
!rm ~/.cache/matplotlib -rf
# 2) 런타임 > 세션다시시작
# 3) 런타임 재시작 이후, 아래 실행
import matplotlib.pyplot as plt
plt.rc('font', family="NanumBarunGothic")

# 또는,

# 2. local PC (예: notebook) 에서 한글 사용:
# ---------------------------
# import matplotlib.pyplot as plt
# plt.rc('font', family='Malgun Gothic')   # for Windows
# plt.rc('font', family='AppleGothic')     # for Mac

"""### >> 참고사항 :

유용한 단축키
1. 실행: ctrl(shift) + enter
2. 주석(comment;#) : (영역선택 후), Ctrl + /
3. 전체 이동 shift: (영역 선택 후), Ctrl + ]/[
  
- 언어 형태: 스트링, 숫자, 트루/퍼스

### 1. 자료형¶

자료형 참고 : 언어형태로는 스트링(문자형), 숫자형, True/False(boolean)이 있다

1-1) 숫자형
"""

# 샵 뒤에 주석 달 수 있음
# 숫자형 :
print(123)
print(123.45)
print(123 + 10.0)
print(123 - 10)
print(123 / 10)   # 나눗셈 divide
print(123 * 10)   # 곱셈 multiply

#특수한 연산 :
print(123 // 10)  # 나눗셈에서 몫
print(123 % 10)   # 나눗셈에서 나머지 **
print(2 * 2 * 2)
print(2 ** 3)     # 거듭제곱
# 복합연산자 +=, -= ...

num = 123     # num <- 123  vs.  123 == 123
print(num)
print(num * 10)

"""##### 기타 : 변수의 생성 규칙 유의사항:
>- 1) Python 명령어는 사용불가
>- 2) 띄어쓰기(공백) 허용불가
>- 3) 첫글자 숫자 사용불가
>- 4) (_언더바 제외)특수문자 허용불가
"""

# 문자형 : string, char
# 문자형 특징: 기준 ("",'',"""""",'''''')
print("hello world")
print('hello\'s world')     # 's 오류 해결책 \'s (역슬레시)
print("""hello
world""")
print('''hello's
world''')                   # 세번 반복하는 스트링 문구는 줄을 바꿔도 사용 가능하다

result = print("a")
print(result) # 프린트는 출력값은 문자열이 아닌  none 값이다 (print()는 단순 출력용)

print(123, "123")      # 숫자형, 문자형
print(123 + 20)
print("123" + "20")
# print("123" + 20)    # ERROR; 동일한 형type 끼리 계산해야 함
print("***" * 10)
print("---" * 10)

# 변수: variable 개념
sample = "오늘은 25.01.07 입니다"
print(sample)

# 변수명 생성 규칙 :
# 1) python 명령은 사용 불가
# 2) 띄어쓰기는 사용 불가
# 3) 첫글자에 숫자 사용 불가
# 4) (_제외한)특수문자 사용 불가(@#$...)
# 한글 변수는 가급적 삼가할 것

우리집_전화번호 = "010-1234-5678"
print(우리집_전화번호)

# 문자형 특징 : 인덱스, (문자형 전용)함수

#         0123...        ...-1
sample = "오늘은 25.01.07 입니다"

print(sample)
print(len(sample))   # 문자형 길이 (= 문자 개수, 인덱스 길이)
print(sample[-1])    # "-1" 은 문자형 마지막 인덱스

# 문자열 인덱스 슬라이싱
sample = "Hello world 는 오늘의 예제문장입니다"
sample[0] + sample[1] + sample[2] + sample[3] + sample[4]
sample[0:4+1]     # slicing(:)  0 <=  < 5
sample[-8:-1]
# Extra :
print(sample[0:5:1])    # [0] <=  < [5], step
print(sample[0:5:2])
print(sample[0:5:3])

# 문자형 특징 : (문자형 전용)함수
# 1) count()  : 문자형 중, 해당 문자 개수 리턴
print(sample)
print(sample.count("o"))
print(sample.count("z"))
print(sample.count("오늘의"))

# 2) find()  : 문자형 중, 해당 문자 인덱스 정보 리턴
print(sample)
print("Hello world 는 오늘의 예제문장입니다".find('예'))
print(sample.find('예'))
print(sample[18])
print(sample[sample.find('예')])

# 없는 문자 찾을 때,
print(sample.find('z'))       # "-1" : 찾는 문자 없음

# 3) replace(a, b) : 문자형 중, a문자 -> b문자로 교체(바꾸기)
print(sample)
print(sample.replace("오늘의", "내일의"))

# 4) split(a) : 문자형 중, a문자 기준으로 나눔split
print(sample)
print(sample.split("는"))
print(sample.split("o"))
print(sample.split(" "))

# 5) 기타
print(sample)
print("".join(['Hello', 'world', '예제문장입니다']))
print("@@".join('abcd'))
print(sample.upper())              # 영문 전체 대문자
print(sample.lower())              # 영문 전체 소문자
print("i am a boy".capitalize())   # 영문 첫글자 대문자
print(" Hello  __bye!   ")
print(" Hello  __bye!   ".lstrip())  # 왼쪽 공백 제거
print(" Hello  __bye!   ".rstrip())  # 오른쪽 공백 제거
print(" Hello  __bye!   ".strip())   # 양쪽 공백 제거

# Boolean 논리값
print(True)         # TRUE(O), true TRue tRue  (X)
print(False)        # FALSE(O), false, FaLse  (X)

# 논리연산 :
print(10 < 20)      # 크기비교 greater than True
print(10 > 20)      # 크기비교 less than False
print(10 >= 20)      # 크기비교
print(10 <= 20)      # 크기비교
# print(10 => 20)      # Error
# print(10 =< 20)      # Error

num1 = 10
num2 = 20
print(num1 < num2)
print(num1 == num2) # 크기비교 같다 : 등식
print(num1 != num2) # 크기비교 다르다

print(True + True)
print(True + True + False)
print(False + False)
#True = 1, False = 0

# 참/거짓 판단함수 :
bool(True), bool(1), bool("python"), bool(sample)
bool(""), bool(0)

"""### Quiz :
- Q1 : 자연수 13 이 홀수인지 짝수인지 판별할 수 있는 방법

- Q2 : 200 seconds 는 몇분 몇초 ?

- Q3 : 80, 75, 55 값에 대한 평균을 구해봅시다

- Q4 : "891010-1234567", "910103-2345678" 주민번호로 성별(남자:1, 여자:2) 을 확인해 봅시다

- Q5 : "010#1234#5678" 값을 전화번호 형태(000-0000-0000) 로 변경해봅시다
"""

#Q1 13이 홀수인지 짝수인지 판단
print(13%2)  # 결과가 1이면 홀수 결과가 0이면 짝수

#Q2 200초는 몇분 몇초
print("200초는", 200 // 60,"분", 200 % 60,"초 입니다.")

#Q3 80, 75, 55 값에 대한 평균을 구하시오
print((80 + 75 + 55) / 3)

#Q4 "891010-1234567", "910103-2345678" 주민번호로 성별을 확인해보기
print("891010-1234567"[7])
id2 = "910103-2345678"
print(id2[7])
print(id2.split("-"))

#Q5 010#1234#5678 -> 010-1234-5678
print("010#1234#5678".replace("#","-"))

#문자형 포맷팅 : 화면에 출력될 문자형 데이터 포맷(꾸며주기) 지정

print(f"200초는 {200 // 60}분 {200 % 60}초 입니다.")  # 파이썬만 있는 편리한 포멧팅 방식

print("200초는 {0}분 {1:.2f}초 입니다.".format(200//60, 200%60,))  # 기존의 방식

"""### 2. 자료구조 :
- 리스트 : [ ]
- 딕셔너리 : { "key":"value" }
- 튜플 : ( )
- 집합 : { }

2-1) 리스트 : [ ]
"""

# 1) 리스트 : [ ]
today_task = [250108, "수요일", True, "강남역"]
print(today_task)
tomor_task = [250109, "목요일", [True, "강남역"]]  # 다중리스트
print(tomor_task)

[250109, "목요일", [True, "강남역"],  { "key" : "value" }, (1,2,3)]

# 리스트 인덱스
#    0         1       2      3
# [250108, "수요일", True, "강남역"]
print(today_task[0])
print(len(today_task))
print(today_task[-1])

#     0        1             2
#                       0       1
# [250109, "목요일", [True, "강남역"]]   #다중리스트(Nested)
print(tomor_task)
print(tomor_task[2])
print([True, '강남역'][1])
print(tomor_task[2][1])

# 리스트 자료구조에서 수정
print(today_task)
print(today_task[2])
today_task[2] = False # "="의 의미는 할당
print(today_task)

# 리스트 자료구조에서 삭제
print(today_task)
del today_task[2]
print(today_task)
del today_task[2]
print(today_task)

# 리스트 자료구조에서 추가/생성
print(today_task)
today_task = today_task + ["강남역"]
print(today_task)

# 리스트 자료구조 함수:
today_task = [250108, "수요일", True, "강남역"]
print(today_task)

# 1) append() 리스트 자료구조에 요소 추가, 반복할수록 추가됨 (가장 자주 사용된다)
today_task.append("추가값")
print(today_task)

# 2) pop() 리스트 자료구조에서 가장 마지막 요소 제거, 반복할수록 제거됨
today_task.pop()
print(today_task)

# 3) remove() 리스트 자료구조에서 해당 요소 제거
print(today_task)
today_task.remove('수요일')
print(today_task)

# 4) count() : 리스트 자료구조에서 해당 요소 개수
today_task = [250108, "수요일", True, "강남역", "강남역"]
print(today_task.count("강남역"))

# 5) extend() : 리스트 자료구조에서 해당 요소 추가 (append와 다르게 한번에 여러개 추가 가능)
print(today_task)
today_task.extend(["추가값1", "추가값2"])
#          =
# today_task.extend("추가값1")
# today_task.extend("추가값2")

print(today_task)

"""2-2) 딕셔너리 : { "key":"value" }"""

# 딕셔너리
dic = {'name': 'pey',
       'phone': '010-9999-1234',
       'birth': '1118',
       'addr': ["경기도", "강원도"]}

# 딕셔너리에서 인덱스:
dic["name"] # 인덱스가 숫자가 아니라 key이다

# 딕셔너리 자료구조에서 함수 :
print(dic.keys())        # 딕셔너리 자료구조에서 key값
print(dic.values())      # 딕셔너리 자료구조에서 value 값
print(dic.items())       # 둘다
print(dic.get('name'))   # **많이 활용

# 튜플 ()
# 특징: 한번 생성하면 수정이 안됨; immutable (예: 123, "Hello")
t1 = ()
t2 = (1,)      # 숫자가 아닌 튜플로 인식하도록 "," 추가
t6 = (1)       # "()"가 튜플이 아닌 수학 공식에서의 괄호임; ex)(1 + 3) * 6
t3 = (1, 2, 3)
t4 = 1, 2, 3
t5 = ('a', 'b', ('ab', 'cd'))
print(t1, t2, t3, t4, t5)
#--------------------------------------------
print((1))     # 튜플이 아닌 괄호 속 숫자로 인식
      #!=
print((1,))

# Extra :
v1, v2, v3 = 1, 2, 3   # v1 = 1; v2 = 2; v3 = 3
print(v1, v2, v3)
v1, v2 = 1, (2, 3)     # v1 = 1; v2 = (2, 3)
print(v1, v2)

# 튜플 자료구조에서 인덱스
print(t5[0])

# 튜플 자료구조간의 상호작용
print(t3, t5)
print(t3 + t5)

# 튜플 사이즈: 길이: 개수
len(t3)

"""2-4) 집합 : { }"""

# 집합 : { }
# 중복 허용 안함 , 순서가 없다 (순서 무관)

print({1,2,3,3,4,10,"Mega", "IT", "IT", False, True}) # 집합 : 여기서 True는 1로 인식되기 때문에 중복되어 생략된다
print((1,2,3,3,4,10,"Mega", "IT", "IT", False, True)) # 튜플
print([1,2,3,3,4,10,"Mega", "IT", "IT", False, True]) # 리스트

# Extra : True == 1; False == 0
print({0,1,2,3,3,4,10,"Mega","IT","IT",False,True})

"""### Quiz :
- Q1 : ["life", "is", "short"] 리스트 자료형 데이터를 이용해서, "life is short" 로 만들어봅시다.

- Q2 : {"사과":"apple", "포도":"grape"} 에서 "포도" 정보가 들어있는지 확인해보고, 만일 있다면, 이에 대응되는 값을 구해봅시다

- Q3 : a = [1,2,3,4] 를 만약을 대비해, b 에도 저장하고, a 첫번째 값(a[0])을 7로 변경했을 때, b 로 백업한 결과를 확인해봅시다

- Q4 : a = [1, 1, 1, 2, 2, 3, 3, 3, 4, 4, 5] 에서 중복 숫자를 제거해봅시다
"""

# Q1 ['life', 'is', 'short'] 리스트 자료형 데이터를 이용해 "life is short"로 만들기
lst= ['life', 'is', 'short']
print(" ".join(lst))

# Q2 {사과 : apple, "포도" : grape}
dict01 = {"사과":"apple", "포도":"grape"}
print("포도" in dict01)
print(dict01["포도"])      # index위치 방식
print(dict01.get("포도"))  # 딕셔너리 함수를 활용

# Q3
a= [1,2,3,4]
print(a)
b = a
print(a,b)
print(a[0])
a[0] = 7
print(a, b)
# 해결방안:
a= [1,2,3,4]
b1 = a.copy()     #참고1
b2 = [1,2,3,4]    #참고2
a[0] =7
print(a, b1,b2)

# Q4
a = [1,1,1,2,2,2,3,3,3]
print(a)
print(set(a),{1,1,1,2,2,2,3,3,3}) # set(): 자료형을 집합으로 바꿔주는 함수
print(tuple({1,1,1,2,2,2,3,3,3})) # 튜플화 시키는 함수
print(list({1,1,1,2,2,2,3,3,3}))  # 리스트화 시키는 함수

"""### 3. 제어문
- if : 조건문
- for : 반복문

3-1) if : 조건문
"""

# 제어문 : if(조건), for(반복), while(조건에 따른 반복)

money = False # True      1 > 0
if money:
  print("택시를 타고 가라") #조건문 안에 해당하는 요소는 들여쓰기 해야 한다
else:
  print("걸어 가라")

print("-"*10)

time = True
money = False      # 1 > 0
if money and time:
  print("택시를 타고 가라")
else:
  print("걸어 가라")

money = 1000
if money > 5000:
  print("택시를 타고 가라")
else:
  if money >= 2000:
    print("버스를 타고 가라")
  else:
    if money > 500:
      print("자전거 타고 가라")
    else:
      print("걸어 가라")

# 개선 :
money = 1000
if money > 5000:
  print("택시를 타고 가라")
elif money >= 2000:
  print("버스를 타고 가라")
elif money > 500:
  print("자전거 타고 가라")
else:
  print("걸어 가라")

# 로지컬 오류는 못찾는다. :
# Logical error 해결방안 > 1) 알고리즘, 2) 테스트
money = 6000
if money >= 2000:
  print("버스를 타고 가라")
else:
  if money > 5000:
    print("택시를 타고 가라")
  else:
    print("걸어 가라")

"""3-2) for : 반복문"""

#          0      1       2
lst01 = ["one", "two", "three"]
for cnt in lst01 :
  print(cnt)
print(cnt)  #for문은 들여쓰기를 하지 않더라도 오류가 나지는 않음

for i in "hello":
  print(i)

#           0     1       2
lst01 = ["one", "two", "three"]
for cnt in range(3): #range(0,3) : 0~2까지, 즉 동일하다 range(0,3,2) : 두번씩 건너뛰면서
  print(cnt, lst01[cnt])

list(range(1, 10, 2))

# marks1.py
marks = [90, 25, 67, 45, 80]   # 학생들의 시험 점수 리스트

number = 0   # 학생에게 붙여 줄 번호
for mark in marks:   # 90, 25, 67, 45, 80을 순서대로 mark에 대입
    number = number +1
    if mark >= 60:
        print("%d번 학생은 합격입니다." % number)
    else:
        print("%d번 학생은 불합격입니다." % number)

# marks1.py
marks = [90, 25, 100, 67, 45, 80]   # 학생들의 시험 점수 리스트

number = 0   # 학생에게 붙여 줄 번호
for mark in marks:   # 90, 25, 67, 45, 80을 순서대로 mark에 대입
    number = number +1
    if mark >= 60:
        print("{0:d}번 학생은 {1:d} 합격입니다.".format(number, mark))
    else:
        print("{0:d}번 학생은 {1:d} 불합격입니다.".format(number, mark))

    # print("continue 이전")
    # continue     # 남은 실행 문장이 있어도 for 문장으로 돌려보낸다
    # print("continue 이후")

    if mark == 100:
        print("{0:d}번 학생은 {1:d} 만점입니다.".format(number, mark))
        print("오늘 업무 종료")
        break # 과정 중에 정지시키는 명령어 (<->)continue

"""### Quiz : 구구단 출력

- (2~9까지) 구구단 출력
- (2~9 중에서 1개)입력받은 값에 따라 구구단 출력
"""

# 구구단 출력
# 2~9

# 알고리즘 접근 :
# 2*1=2
# 2*2=4
# ...
# 3*1=3
# ...

for i in [2,3,4,5,6,7,8,9]:  # = range(9)
  # print(i)
  # print("-"*10)
  for j in [1,2,3,4,5,6,7,8,9]:
    #print(j)
    print("{0} * {1} ={2} ".format(i, j, i*j))
  print("-"*10)

"""### Quiz :

- 숫자를 입력받고, "*" 을 이용하여 아래 모양을 완성해 주세요
"""

# 초보적 솔루션
print("*")
print("**")
print("***")
print("****")
print("*****")

# 개선된 솔루션
num= 5
for i in range(num) :
  print("*" * (i+1)션

"""참고 : 리스트 컴프리헨션(List Comprehension)"""

# 리스트 컴프리헨션
a = [1,2,3,4]
result = [num * 3 for num in a]
print(result)

# vs. for 구문으로 동일한 구현:
a = [1,2,3,4]
result = []
for num in a:
  result.append(num*3)
print(result)

# for 구문으로 동일한 구현:
a = [1,2,3,4]           # [1, 6, 3, 12]
result = []
for num in a:
  if num % 2 == 0:      # 짝수 : 2로 나눈 나머지 0 의미
    result.append(num*3)
  else:
    result.append(num)
print(result)

# vs. 리스트 컴프리헨션
a = [1,2,3,4]
# result = [num * 3 for num in a if num % 2 == 0]
result = [num * 3 if num % 2 == 0 else num for num in a]
print(result)

"""3-3) while : if 조건문 + for 반복문 합쳐진 기능/명령"""

treeHit = 0
while treeHit < 10:
     treeHit = treeHit +1
     print("나무를 %d번 찍었습니다." % treeHit)
     if treeHit == 10:
         print("나무 넘어갑니다.")

# input() : 입력받는 함수
# 특징: 입력 받은 값은 무조건 문자형으로 인식함
input("숫자를 입력해주세요 : ")

"""### Quiz : 로또번호 자동 생성기
- 조건1) 1 - 45
- 조건2) 6개
- 조건3) 중복 불가
"""

# 파이썬 랜덤함수(난수)
# random 라이브러리 활용(예) : 난수 임의값 randomly 발생
import random

random.choice(num_all)     # 1개 선택
random.sample(num_all, 6)  # 6개 선택
random.randint(1,3)        # 정의한 범위에서 정수형 수를 1개 선택 (복원추출)

# Q 로또번호 자동 생성기

# 알고리즘(조건)
# 1) 숫자 필요 (1-45)
# 2) 숫자 뽑기 (6번 반복)
# 3) 중복 불가 (복원추출 불가)
# 4) 로또번호 완성

num_all = list(range(1, 46))

# 구현방안 1)
random.sample(num_all, 6) # 6개 선택

# 구현방안 2) 중복된 숫자가 나올 수 있다
num_lotto = []
for i in range(6) :
  num_choice = random.choice(num_all)
  num_lotto.append(num_choice)
  #print((i+1),"회", num_choice)

print(num_lotto)

# 구현방안 3)
num_lotto = []
while len(num_lotto) < 6 :               # 선택한 개수가 < 6 이면 참 (while 문장 지속)
  num_choice = random.choice(num_all)    # 선택한 개수가 6 이면 거짓 (while 문장 stop)
  if num_choice not in num_lotto:
    num_lotto.append(num_choice)

print(num_lotto)

# 구현방안 4)
num_lotto = []
while len(num_lotto) < 6:             # 선택한 개수가 < 6 이면, 참 (while 문장 continue)
  num_choice = random.randint(1,45)   # 선택한 개수가 6 이면, 거짓 (while 문장 stop)
  if num_choice not in num_lotto:
    num_lotto.append(num_choice)

print(num_lotto)

# Extra : while 과 break 함수를 이용한 예제
# 1~6 까지의 숫자풀에서 while 함수로 반복하다가, 5까지 나왔을 때 break 하는 예제
while True:
  for i in range(6):
    print(i)
    if i == 5:
      flag = "중단"
    else
      flag = "계속"
  if flag == "중단":
    break

"""### 4. 함수 :
필요성 :
- 반복적인 작업 생산성, 효율성 제고 측면
- 유지보수 용이성 등

4-1) 함수의 유형
> def func(매개변수): <p>
> -----  실행문장 <p>
>   return 반환값 <p>

> 매개변수 (O) + 반환값 (O) <p>
> 매개변수 (X) + 반환값 (O) <p>
> 매개변수 (O) + 반환값 (X) <p>
> 매개변수 (X) + 반환값 (X) <p>
"""

def type1(arg):   # 매개변수(O) + 리턴(O)
  return arg

def type2():      # 매개변수(X) + 리턴(O)
  arg = 1
  return arg

def type3(arg):   # 매개변수(O) + 리턴(X)
  print(arg)

def type4():      # 매개변수(X) + 리턴(X)
  arg = 1
  print(arg)

print("type1:",type1(10))
print("type2:",type2())
print("type3:",type3(20))
print("type4:",type4())

# 명령어 def로 "hello world" 출력(print) 하는 함수 만들기
#함수
def func01():
  print("hello world")

# 함수 실행
func01()

# 구구단 함수 :
def func02():
  for i in [2,3,4,5,6,7,8,9]:
    for j in [1,2,3,4,5,6,7,8,9]:
      print("{0} x {1} = {2}".format(i,j,i*j))  # 2 * 1 = 2
    print("-"*10)

# 함수 실행
func02()

# 구구단 함수 : 입력값(parameter매개변수) 에 따라 결과 출력
def func03(num):
  # for i in [num]:             #
  for i in range(num,num+1):    #  num <=   < num+1
    for j in [1,2,3,4,5,6,7,8,9]:
      print("{0} x {1} = {2}".format(i,j,i*j))  # 2 * 1 = 2
    print("-"*10)

# 알고리즘 :
# num = 2

# 함수 실행
func03(12)

# 로또 번호 생성 함수
def lotto():
  num_lotto = []
  while len(num_lotto) < 6 :               # 선택한 개수가 < 6 이면 참 (while 문장 지속)
    num_choice = random.randint(1, 45)     # 선택한 개수가 6 이면 거짓 (while 문장 stop)
    if num_choice not in num_lotto:
      num_lotto.append(num_choice)

  return num_lotto


# 영역 전체 shift(들여쓰기): 영역선택 후, ctrl ]

# 함수 실행
result = lotto()
print(result)

def add(a, b = 10):  #b의 기본값을 정해놓아 b를 따로 입력하지 않으면 10이 더해지도록 함, a와 같이 처음에 오는 값에는 적용 안됨
  return a+b

#함수 실행
add(1,10)

def add_m(a = 10, b = 20):
  return a+b, a-b

#함수 실행
add_m(1, 10)

"""# 여기까지 정리"""

def add(a,b,c):
  return a+b+c


def add_multi(*a):    # (가변형)다중 값을 입력받을 수 있음 (=리스트 자료구조로 해석)
  result = 0
  for num in a :     #[10,20,30,40...]
    result = result + num
  return result

#함수 실행
add_multi(10)

# Extra : 리스트 컴프리헨션
a = [10,30, 60, 9, 10,1]
sum([num for num in a])

"""함수의 유형"""

from re import X
매개변수 (0) + 반환값 (0)
매개변수 (0) + 반환값 (X)
매개변수 (X) + 반환값 (0)
매개변수 (X) + 반환값 (X)

add(20)

"""빅데이터 분석 기사
코딩테스트 연습
"""

# 함수 팩토리얼

# 입력값을 받는다고 가정:

num = 4
output = 1
for i in range(num, 0, -1):
  output = output * i
  print(i)    # 3, 3-1, 3-2
print(output)

def fact(num):
  output = 1
  for i in range(num, 0, -1):
    output = output * i
  print(i)
  return output

fact(4)

#369 게임
# 숫자 입력값을 받는 것으로 가정
# 알고리즘
# num = 10
# for i in range(1,num+1,1):
#   if i % 3 == 0 or i%6 == 0 or i%9 == 0:
#     print(i, "clap")
#   else:
#    print(i)

# 함수로 일반화 :
def game369(num):
  for i in range(1,num+1,1):
    if i%3 == 0 or i%6 == 0 or i%9 == 0:
      print(i, "clap")
    else:
     print(i)

# 함수 테스트:
game369(10)

# 함수의 효력범위
# local :
a=1
print(a)

a = 1
def vartest(a):
    a = a +1    # a?  2

vartest(a)      # a = 1  즉, 함수내에서의 a와 밖에서는 다르다
print(a)

# 개선 :
a = 1
def vartest_rev(a):
    a = a +1    # a?  2
    return a

print(vartest_rev(a))

# global
a = 1
print(a)           # 1

def vartest():
    global a
    a = a+1       # 2

vartest()
print(a)

# 람다 함수
def vartest_lambda(a):
    a = a +1
    return a

print(vartest_lambda(3))
print("-"*10)

func_lambda = lambda a: a + 1
print(func_lambda(3))

# [1,1,2,3,4,5],1,2
lst02 = [1,1,2,3,4,5]
n = 1
output = 0

for i in lst02:
  if i == n:
   output += 1

# print(output)

lst02.count(n)

# 함수로 일반화
def solution(array,n):
    answer = 0
    for i in array:
      if i == n:
        answer += 1
      return answer

def solution2(array, n):
    return array.count(n)

print(solution([1,1,2,3,4,5], 1))
print(solution2([1,1,2,3,4,5], 1))

# 두수의 차

# 2,3 -1
# 100, 2 98

def solution(num1, num2):
    answer = 0
    answer = num1 - num2
    return answer

solution(2,3)
solution(100,2)

print("a", "b", end = "\t")
print("c", "d")

# 파일 입출력, 읽고 쓰기
# 파일 쓰기
f = open("새파일.txt", 'w') # 파일탐색기를 이용해 파일을 여는 함수, w : write
f.write("첫번째 파일 쓰기 연습. \n")
f.write("파일 읽기 연습")
f.close()

# 파일 읽기
f = open("새파일.txt", 'r')  # r: read
print(f.readlines())
f.close()

f = open("새파일.txt", 'r')  # r: read
print(f.readline())
f.close()

# 파일 쓰기 : a (append 모드)
f = open("새파일.txt", 'a')  # a: append
f.write("첫번째 파일 쓰기 연습. \n")
f.close()

# 파일 읽기 rotjs
with open("새파일.txt", 'r') as f:
  f.readlines()

# Extra:
with open("/content/sample_data/california_housing_test.csv", 'r') as f:
  #print(f.readlines())
  output = f.readlines()

# for txt in output:
#   print(f.readlines())

# pandas 라이브러리
import pandas as pd
df = pd.read_csv("/content/sample_data/california_housing_test.csv")
df.head()

"""Quiz : 구글 입사문제 중에서
1부터 10,000까지 8이라는 숫자가 총 몇번 나오는가?

8이 포함되어 있는 숫자의 갯수를 카운팅 하는 것이 아니라 8이라는 숫자를 모두 카운팅 해야 한다.

(※ 예를들어 8808은 3, 8888은 4로 카운팅 해야 함)
"""

# print(int('123'))   # 문자를 정수로
# print(str(123))     # 숫자를 문자로

sum = 0
for n in range(1,10000+1):
  # print(n, str(n).count('8'))
  cnt_8 = str(n).count('8')
  sum = sum + cnt_8
  # if cnt_8 > 0:
  #   # print(n,cnt_8, sum)
  #   pass

print(sum)

# Extra:
# "[1,2,3,4,88,8,808]".count('8')
str([n for n in range(1,10000+1)]).count('8')

# 프로그램 실행 (lotto.py)
import sys
import random

args = sys.argv[1]
# for i in args:
#     print(i)
num_lotto =[]
while len(num_lotto) < int(args):             # 선택한 개수가 < 6 이면, 참 (while 문장 continue)
  num_choice = random.randint(1,45)   # 선택한 개수가 6 이면, 거짓 (while 문장 stop)
  if num_choice not in num_lotto:
    num_lotto.append(num_choice)

print(num_lotto)

# 클래스

class Calculator:        # 클래스 이름은 구분을 위해 첫글자에 대문자가 일반적
    def __init__(self):  #__init__ 가장먼저 실행되는 함수를 지정(처음에만 실행)
        self.result = 0  # self 객체와 대응되는 개념 (클래스안에 항상 포함되어 있다)

# 클래스 안의 함수를 매소드라고 한다
    def add(self, num):
        self.result += num
        return self.result

# 클래스 상속 : 괄호안에 상속받을 클래스를 입력 (상속받을 클래스)
class ChildCalculator(Calculator):
    def multipy(self, num):
        self.result *= num
        return self.result

# 클래스 다형성 : 오버라이팅(overriding) (기타: 오버로딩)
    def add(self, num):
        self.result += num *10
        return self.result

#객체 생성
cal1 = Calculator()    #클래스 선언
cal2 = Calculator()
cal3 = ChildCalculator()

print(cal1.add(3))
print(cal2.add(3))
print(cal3.add(3))

print(cal3.multipy(6))

# 모듈 : 파일 형태 (*.py)
import module_test

# 모듈함수 테스트
module_test.game369(20)

# 모듈함수 클래스 테스트
cal4 = module_test.ChildCalculator()

print(cal4.add(10))

cal5 = module_test.Calculator()

cal5.add(10)

"""### Quiz : 숫자계에 우영우 찾기
1000 을 입력받고, 0 ~ 1000 까지 일련에 숫자에서
- 1) 앞으로 읽어도, 거꾸로 읽어도 동일한 숫자가 몇개인지 알아봅시다.
- 2) 20번째 숫자는 무엇일까요?

예) 0 ~ 9, 11, 22, 33, ... 101, 111
"""

num = 123    # 321
str_num = str(num) # str 문자형으로 변경
str_num[0]

# 1)숫자를 입력받는다           (예: 123)
# 2)숫자를 문자로 변경          (예: '123')
# 3) 문자 -> (정방향) 구하고    (예: 1,2,3)
# 4) 문자 <- (역방향) 구하고    (예: 3,2,1)
# 5) == 4) 같은지 비교 ?

# 1)숫자를 입력받는다
num = input("숫자를 입력해주세요 : ")
# 2)숫자를 문자로 변경
str_num = str(num)